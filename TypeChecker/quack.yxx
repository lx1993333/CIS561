/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

 /* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
* can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    /* Abstract syntax tree values */
    AST::ASTNode* node;  // Most general class
    AST::Class* clazz;
    AST::Ident* ident;   // Identifiers are used in many places
    AST::LExpr* l_expr;
    AST::Statement* statement;
    // Alas, looks like we need a member per sequence type
    AST::Method* method;
    AST::Actuals* actuals;
    AST::Block* block;
    AST::Classes* classes;
}

 // The following token values are actually used
%token <str> STRING_LIT
%token <str> IDENT
%token <num> INT_LIT
 // The following tokens don't need values
%token IF ELIF ELSE FI WHILE
%token CLASS DEF EXTENDS TYPECASE
%token RETURN 
%token ATLEAST ATMOST EQUALS
%token AND OR NOT NEG

 // Abstract syntax tree nodes
%type <l_expr> l_expr
%type <statement> stmt
%type <node> program r_expr type_case
%type <classes> classes
%type <block> block actual_args
%type <block> stmt_block elif_stmt type_alternative
%type <actuals> class_args 
 //%type <formals> formals formals_nonempty
 //%type <methods> methods
%type <method> method
%type <node> if_stmt else_stmt 
%type <clazz> class
%type <ident> classExtends method_type

%%

 /* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program:  classes {*root = $1;}
          ;

classes:  class {$$ = new AST::Classes();$$ ->append($1);}
        | classes class {$1->append($2); $$ = $1;}
        | classes stmt {$1->append($2); $$ = $1;}
        | %empty {$$ = new AST::Classes();}
        ;

class: CLASS IDENT '('class_args')' classExtends '{' block '}' { 
                                                  AST::Ident* class_name = new AST::Ident($2);
                                                  $$ = new AST::Class(*class_name,*$4,*$6,*$8);
                                                  };

classExtends: EXTENDS IDENT { $$ = new AST::Ident($2);}
              | %empty      { $$ = new AST::Ident("Nothing");}
              ;

 /* Standard recursive definition for a non-empty sequence. */

class_args: IDENT ':' IDENT { $$ = new AST::Actuals(); 
                              AST::Ident* id1 = new AST::Ident($1); 
                              AST::Ident* id2 = new AST::Ident($3); 
                              $$->append(new AST::Argus(*id1,*id2));
                            }
            |class_args','IDENT ':' IDENT { $1->append(new AST::Argus(*new AST::Ident($3),*new AST::Ident($5))); $$ = $1;}
            |%empty {$$ = new AST::Actuals();}
            ;

block: block stmt { $1->append($2); $$ = $1;}
     | stmt { $$ = new AST::Block(); $$->append($1);}
     |%empty {$$ = new AST::Block();}
    ;
    
method: DEF IDENT '('class_args')' method_type '{' stmt_block '}' { AST::Ident* method_name = new AST::Ident($2);
                                                                          $$ = new AST::Method(*method_name,*$4,*$6,*$8);
                                                                  };

method_type: ':' IDENT {$$ = new AST::Ident($2);}
              | %empty {$$ = new AST::Ident("Nothing");}
              ;

stmt_block: stmt_block stmt {$1->append($2); $$ = $1;}
     | stmt {$$ = new AST::Block(); $$->append($1);}
     | %empty {$$ = new AST::Block();}
    ;

stmt: %empty { }
    |l_expr ':' IDENT '=' r_expr';' {$$ = new AST::Statement(*new AST::Assign(*new AST::TypeExtend(*$1,*new AST::Ident($3)), *$5));}
    |l_expr '=' r_expr';' {$$ = new AST::Statement(*new AST::Assign(*$1, *$3));}
    |r_expr';' { $$ = new AST::Statement(*$1);}
    |RETURN r_expr ';' {$$ = new AST::Statement(*new AST::Return_opt(*$2));}
    |RETURN ';' {$$ = new AST::Statement(*new AST::Return_opt(*new AST::Ident("Nothing")));}
    |if_stmt { $$ = new AST::Statement(*$1);}
    |type_case {$$ = new AST::Statement(*$1);}
    |WHILE '('r_expr')' '{' stmt_block'}' {$$ = new AST::Statement(*new AST::While(*$3,*$6));}
    |method {$$ = new AST::Statement(*$1);}
    ;

l_expr: IDENT { $$ = new AST::Ident(std::string($1)); dump($$); }
        |r_expr '.' IDENT {$$ = new AST::Dot(*$1,*new AST::Ident($3));}
        ;

type_case: TYPECASE r_expr '{' type_alternative '}' {$$ = new AST::TypeCase(*$2,*$4);};

type_alternative: IDENT ':' IDENT '{' stmt_block '}'{$$ = new AST::Block(); $$-> append(new AST::Type_Alternatives(*new AST::Ident($1),*new AST::Ident($3),*$5));}
                | type_alternative IDENT ':' IDENT '{' stmt_block '}' {$1-> append(new AST::Type_Alternatives(*new AST::Ident($2),*new AST::Ident($4),*$6)); $$ = $1;}
                | %empty {$$ = new AST::Block();}
                ;

if_stmt: IF r_expr '{' stmt_block '}' elif_stmt ELSE '{' stmt_block '}' {$$ = new AST::If(*$2, *$4, *$6, *$9);}
        |IF r_expr '{' stmt_block '}' elif_stmt  {$$ = new AST::If(*$2, *$4, *$6, *new AST::Block());}
        ;

elif_stmt: ELIF r_expr '{'stmt_block'}' elif_stmt {$$ = new AST::Block(); AST::ASTNode *if_stm = new AST::If(*$2, *$4, *$6, *new AST::Block()); $$->append(if_stm);}
          | %empty {$$ = new AST::Block();}
          ;


actual_args: r_expr {$$ = new AST::Block(); $$ ->append($1);}
    | %empty    {$$ = new AST::Block();}
    | actual_args ',' r_expr { $1->append($3); $$ = $1;}
    ;
    
r_expr: l_expr { $$ = $1;}
    | r_expr '+' r_expr  { $$ = new AST::Plus( *$1, *$3 ); dump($$);}
    | r_expr '-' r_expr  { $$ = new AST::Minus( *$1, *$3 ); dump($$);}
    | r_expr '*' r_expr  { $$ = new AST::Times( *$1, *$3 ); dump($$);}
    | r_expr '/' r_expr  { $$ = new AST::Div( *$1, *$3 ); dump($$);}
    | r_expr '>' r_expr  {$$ = new AST::Large( *$1, *$3 ); dump($$);}
    | r_expr '<' r_expr  {$$ = new AST::Less( *$1, *$3 ); dump($$);}
    | r_expr ATLEAST r_expr  {$$ = new AST::Atleast( *$1, *$3 ); dump($$);}
    | r_expr ATMOST r_expr  {$$ = new AST::Atmost( *$1, *$3 ); dump($$);}
    | r_expr EQUALS r_expr {$$ = new AST::Equals( *$1, *$3 ); dump($$);}
    | r_expr AND r_expr {$$ = new AST::And( *$1, *$3 ); dump($$);}
    | r_expr OR r_expr {$$ = new AST::Or( *$1, *$3 ); dump($$);}
    | r_expr NOT r_expr {$$ = new AST::Not( *$1, *$3 ); dump($$);}
    | NEG r_expr {}
    | IDENT '(' actual_args ')'  {$$ = new AST::Method_call(*new AST::Ident($1),*$3);}
    | r_expr '.' IDENT '(' actual_args ')' {$$ = new AST::Dot(*$1,*new AST::Method_call(*new AST::Ident($3),*$5));}
    |'(' r_expr ')'  { $$ = $2; }
    | INT_LIT {$$ = new AST::IntConst($1); dump($$);}
    | STRING_LIT {$$ = new AST::StringConst($1); dump($$);}
    ;
    
    
  // leaf: IDENT  { $$ = new AST::Ident(std::string($1)); dump($$); }
  //      |INT_LIT {$$ = new AST::IntConst($1); dump($$);}
  //      |STRING_LIT {$$ = new AST::Ident(std::string($1)); dump($$);}
  //      ;
%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
 { 
  report::error_at(loc, msg);
 }

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
