/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

 /* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
* can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
}

 // The following token values are actually used
%token <str> STRING_LIT
%token <str> IDENT
%token <num> INT_LIT
 // The following tokens don't need values
%token IF ELIF ELSE FI WHILE
%token CLASS DEF EXTENDS TYPECASE
%token RETURN 
%token ATLEAST ATMOST EQUALS
%token AND OR NOT NEG


%%

 /* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program:  classes {}
         |%empty {}
          ;

classes:  class {}
        | classes class {}
        | classes stmt {}
        ;

class: CLASS IDENT '('class_args')' '{' block '}' { }
      | CLASS IDENT '('class_args')' EXTENDS IDENT '{' block '}' { }
      ;

 /* Standard recursive definition for a non-empty sequence. */

class_args: IDENT ':' IDENT {}
            |class_args','class_args { }
            |%empty { }
            ;

block: stmt ';' block { }
     | block block {}
     | stmt {}
     | DEF IDENT '('class_args')' ':' IDENT '{' stmt_block '}' { }
     | DEF IDENT '('class_args')''{' stmt_block '}' { }
    ;

stmt_block: stmt_block stmt { }
     | stmt { }
     | %empty
    ;

stmt: %empty { }
    |IDENT { }
    |l_expr ':' IDENT '=' r_expr';' {}
    |l_expr '=' r_expr';'
    |r_expr';' { }
    |RETURN r_expr ';' {}
    |RETURN ';' {}
    |if_stmt ELSE '{' stmt_block '}' {}
    |if_stmt {}
    |type_case {}
    |WHILE '('r_expr')' '{' stmt_block'}' {}
    ;

l_expr: IDENT    {}
        |r_expr '.' IDENT    {}
        ;

type_case: TYPECASE r_expr '{' type_alternative '}' {};

type_alternative: IDENT ':' IDENT '{' stmt_block '}'{}
                | type_alternative type_alternative {}
                | %empty {}
                ;

if_stmt: IF r_expr '{' stmt_block '}' {}
        | if_stmt ELIF r_expr '{'stmt_block'}'{}
        ;

actual_args: r_expr { }
    | %empty    {}
    | r_expr ',' r_expr   {}
    ;
    
r_expr: INT_LIT  { }
    | STRING_LIT {}
    | l_expr {}
    | r_expr '+' r_expr  {}
    | r_expr '-' r_expr  {}
    | r_expr '*' r_expr  {}
    | r_expr '/' r_expr  {}
    | r_expr '>' r_expr  {}
    | r_expr '<' r_expr  {}
    | r_expr ATLEAST r_expr  {}
    | r_expr ATMOST r_expr  {}
    | r_expr EQUALS r_expr {}
    | r_expr AND r_expr {}
    | r_expr OR r_expr {}
    | r_expr NOT r_expr {}
    | NEG r_expr {}
    | IDENT '(' actual_args ')'  {}
    | r_expr '.' IDENT '(' actual_args ')' {}
    |'(' r_expr ')'  {}
    ;
%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
 { 
  report::error_at(loc, msg);
 }

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
